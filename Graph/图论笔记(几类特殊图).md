### 记几类特殊图
>被傻逼abc e题击败了 遂记录之

#### 0.一些概念
**1).团** ：一个完全子图
**2).最大独立集** ：一个点数最多的顶点集，其中任意两个顶点之间都没有边
>可以发现这两是对偶关系

**3).最小染色**：用最少的颜色给点染色使得所有边连接的两点颜色不同。
**4).色数**：最小染色中使用的颜色数
>其实下面所述都属于完美图，即最大团=最小染色数


#### 1.可比图->逆序图
可比图：本质Hasse图，刻画在偏序关系上的图
两元素之间可比，则存在一条无向边
>通常我们会画成有向图（如果定义了偏序关系），但本质是无向的（只关心可比关系）

**链**：构成一条链的元素两两之间可比 $\Rightarrow$ 对应图中的 团 。
**反链**：构成一条反链的元素两两之间不可比 $\Rightarrow$ 对应图中的 独立集 。
**链划分**：将一个偏序集划分成若干条链


**Dilworth定理**：最小链覆盖数 = 最大反链的大小 = 最大独立集的大小
**对偶的Dilworth定理**：最小反链覆盖数 = 最长链的大小 = 最大团的大小

>其实此处的最长链是好求的，就是DAG的最长路
>最大反链也是好求的，跑个传递闭包，按二分图的方法跑最小链覆盖就行

![alt text](md.img/image.png)
>这是个整除图来着，红色的是链 蓝色的是最大反链 注意到最小链划分数是2，最大反链的元素数目也是2

**逆序图**：给定一个序列，逆序图是表示序列中元素之间逆序关系的图
具体来说，对于序列中的元素`a[i]`和`a[j]`，如果`i<j`且`a[i]>a[j]`，则存在一条从i到j的无向边
我们把逆序图套到可比图上，发现，逆序图的最长反链（最大独立集）就是最长上升子序列
因为最长上升子序列中任意两个元素之间都不存在逆序关系，即两两不可比
同理我们把这个序列划分成最少的下降子序列，会发现，这个个数正好是最长上升子序列的长度
即**Dilworth定理**：最小链覆盖数 = 最大反链的大小

同理，逆序图的最长链（最大团）就是最长下降子序列，其中任意两个元素之间都存在逆序关系，即两两可比
同理我们把这个序列划分成最少的上升子序列，会发现，这个个数正好是最长下降子序列的长度
即**对偶的Dilworth定理**：最小反链覆盖数 = 最长链的大小

>所以我们看到可比图的时候，先想想这个可比图的链是啥含义，反链又是啥含义，这样有可能把一般可比图的求最大反链的O(n^1/2*m)优化成O(nlogn)

#### 2.二分图
>详细证明见二分图最大匹配.cpp 注释部分

**二分图最大匹配** 最大流$O(n^1/2*m)$

**二分图最小点覆盖**：在一张无向图中选择最少的顶点，满足每条边至少有一个端点被选
二分图中，最小点覆盖中的顶点数量等于最大匹配中的边数量。（Kőnig 定理）

**二分图最大独立集**：在一张无向图中选择最多的顶点，满足两两之间互不相邻。
二分图中，最大独立集中的顶点数量等于n-最小点覆盖中的顶点数量
>其实对于一般图来说，最大独立集也=n-最小点覆盖中的顶点数量

**有向无环图最小路径覆盖**：在一张有向图中，选择最少数量的简单路径，使得所有顶点都恰好出现在一条路径中。
->有向无环图的最小路径覆盖数等于顶点数减去最大匹配数
通过dag构造的二分图如下：
将每个顶点拆成两个顶点，v_in v_out
对于原图中的每条有向边u->v，在二分图中连边v_in-u_out

>也就是说 对于一般的dag我们可以通过这个转换 最大流O(n^1/2*m)求出最小链划分
>注意路径是不交的 如果要相交先对原图跑一个传递闭包


#### 3.区间图/一堆区间的简单问题

**区间图**：给定n个区间，区间图是表示区间之间包含关系的图
区间有交集则连边

>注意到区间图没有长度 $\ge 4$ 的无弦环，所以他是弦图
随便画画图就能证明

##### 1).最大团：直线上重叠层数最多的位置 <-> 最小染色:给每个区间染色使得重叠区间颜色不同，最少颜色数
>此处的最大团=最小染色比较显然

经典模型：求区间图最大团
>把区间变成{l,+1},{r,-1},然后对坐标排序,注意相同的时候+1放前面即可，做扫描线即可

经典模型：求区间最小染色的方案
>建立小根堆，里面存{某颜色的结束时间, 颜色ID}，每次取出堆顶，如果堆顶的结束时间小于当前区间的开始时间，则该区间可以染该颜色，否则该区间无法染色，需要新开一个颜色，然后加入堆中

##### 2).最大独立集：求最多的不交区间数
>这是经典的，按右端点 $R$ 从小到大排序，选了 $i$ 后，下一个选 $L_j > R_i$ 的第一个 $j$。

当然当我们要求最小点覆盖的时候只要用n减去最大独立集即可

##### 3).选最少的点，使得每个区间内至少包含一个点。
>经典贪心：按右端点 $R$ 从小到大排序。如果当前区间不交，贪心地选该区间的最右端点（因为它能尽可能多地向右覆盖后续区间的左端点）。

当然其实我们知道2和3是等价的，你可以发现他们的本质是一样的

##### 4).别的附赠小甜品

给定大区间 $[S, T]$ 和 $N$ 个小区间，求最少选几个小区间能完全覆盖 $[S, T]$

>按l排序，维护当前已覆盖到的右边界r，在当前区间中找最大的r即可

每个区间 $[L_i, R_i]$ 有权值 $W_i$，求互不相交的区间集合使得权值和最大
>随便dp即可

#### 4.弦图
**弦图**：没有大于 3 的“无弦环”的图，即他没有大洞
>树也是弦图！

##### 1).最大势算法(mcs)生成完美消除序列(peo)

**完美消除序列**：
序列 $v_1, \dots, v_n$ 中，对于任意 $v_i$，其在序列后方（$v_{i+1} \dots v_n$）的所有邻居构成一个团（即两两相连）。

给图中的每个点分配一个编号，$n$ 倒数到 $1$ 进行编号。
贪心策略： 每次从未编号的节点中，选择与“已编号节点”相连边数最多的那个点进行编号。
>感性理解一下，每次选相连边数最多的那个点可以保证团的纯度

我们需要维护一个 $label[i]$：表示节点 $i$ 目前与多少个已编号的节点相连

朴素实现是 $O(n*n)$ 的，不够优秀，我们可以用一个懒更新的手法把他变成 $O(n+m)$ ,具体来说，我们用一个桶 $st[i]$ 存储 $label=i$ 的点,然后维护一个 $mxlab$ 指向桶的末尾，再开个 $vis[i]$ 表示 $i$ 是否被编号过,这样我们每次在取的时候可以检查 $vis$ 数组，不成立的废弃即可。

注意到，边 $(u,v)$ 最多贡献一次 $label$ 值，$st$ 的 $push$ 次数不超过 $m$ ，$mxlab$ 的回退总量 $ <= n$ (一个点的邻接点数 $<=n-1$ ) ，所以复杂度是 $O(n+m)$ 的。

##### 2).验证完美生成序列

考虑优化一下PEO的定义，把他写成归纳的形式：
对于当前点 $u$，我们不需要检查其后方邻居是否“两两”有边。我们只需要找到 $u$ 在序列后方位置最靠前的那个邻居，记为 $p$。
只要满足：$u$ 的所有其他后方邻居，都是 $p$ 的邻居，那么 $u$ 就满足性质。
>随便归纳一下就行，类似于n循环比赛

考虑实现

用 $rk$ 反映射 $peo$ 序列，$rk[i]$ 表示 $i$ 在 $peo$ 中的位置,我们处理出每一个 $p$ 的检查列表 $chklis[p]$, 然后按 $peo$ 序列的顺序（其实这个是不必要的，按1-n都可以），遍历 $p$ ，给 $p$ 的邻居打上时间戳，然后在对检查列表里的点检查邻居即可。

注意到每个 $u$ 只属于 一个 $p$ , 所以时间复杂度是 $O(n+m)$ 的。

##### 3).求解最大团，色数和最大独立集

根据完美图性质，最大团=最小染色数。
这个最大团已经在生成PEO的过程中算出来了。
回忆 $label[i]$：表示节点 $i$ 目前与多少个已编号的节点相连。
根据弦图性质，这 $label[u]$ 个邻居加上 $u$ 自己，恰好构成了一个大小为 $label[u] + 1$ 的团。

最大独立集，贪心着求，开 $vis$ 数组，按PEO选尽量前面即可。
>感性理解，考虑交换论证，设u，v,u的出现早于v，u的团包含v，考虑选u，团内只能选一个，不劣，考虑选v，扼杀了v构成的团内的某些可能，劣。

