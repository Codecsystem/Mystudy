>从广义莫比乌斯反演的角度思考各类反演魔术

此笔记主要总结之前的二项式反演/莫比乌斯反演
然后补充斯特林反演/mix-max容斥/容斥的相关技术

### 一切的基石：广义莫比乌斯反演


我们在数论中熟悉的 $\sum_{d|n}\mu(d) = [n=1]$ 其实只是冰山一角。所有的反演公式本质上都是在一个特定的偏序集( $DAG$ )上求解线性方程组。

#### 1.1 定义

设 $P$ 是一个局部有限的偏序集。

Zeta 函数 (前缀和) $\zeta(x, y)$：
表示 $x$ 是否小于等于 $y$。


$$\zeta(x, y) = \begin{cases} 1 & x \le y \\ 0 & \text{otherwise} \end{cases}$$

>$\zeta(x, y) = 1$ 等价于DAG上存在从 $x$ 到 $y$ 的路径。

我们现在知道

$$ g(y) = \sum_{x \le y} \zeta(x, y) f(x)$$
 
我们现在要求解

$$f(y) = \sum_{x \le y} \mu(x, y) g(x)$$

于是我们有这个式子

Möbius 函数 (差分系数) $\mu(x, y)$：

$$\mu(x, y) = \begin{cases} 1 & x = y \\ -\sum_{x \le z < y} \mu(x, z) & x < y \\ 0 & \text{otherwise} \end{cases}$$

或者说

$$\sum_{y \preceq z \preceq x} \mu(z, x) = [x=y] = \delta(x,y)$$

>你想求 $x$ 到 $y$ 的莫比乌斯函数值？
你就把从 $x$ 出发，到 $y$ 之前所有中间节点 $z$ 的 $\mu(x, z)$ 加起来，取个负号，就是 $\mu(x, y)$。


怎么推导呢？


定义两个双变量函数 $A, B$ 的**狄利克雷卷积**（Dirichlet Convolution）为：

$$(A * B)(x, y) = \sum_{x \le z \le y} A(x, z) B(z, y)$$

这本质上就是**矩阵乘法**。如果你把 $A(x, z)$ 看作矩阵 $A$ 的第 $x$ 行第 $z$ 列元素，把 $B(z, y)$ 看作矩阵 $B$ 的第 $z$ 行第 $y$ 列元素，上述公式就是 $(AB)_{xy}$。

**推导单位元 $\delta$**

我们想要求解 $f(y)$，这需要逆运算。在做逆运算之前，必须先知道在这个乘法规则下，什么东西相当于数字 $1$（保持原值不变）。

设单位元函数为 $\delta(x, y)$。
对于任意函数 $A$，必须满足 $A * \delta = A$。
即：
$$\sum_{x \le z \le y} A(x, z) \delta(z, y) = A(x, y)$$

观察这个等式：
1.  **当 $x=y$ 时**：
    式子变为 $A(x, x)\delta(x, x) = A(x, x)$。
    为了对任意 $A$ 成立，必须有 **$\delta(x, x) = 1$**。

2.  **当 $x < y$ 时**：
    式子展开为 $A(x, x)\delta(x, y) + \dots + A(x, y)\delta(y, y) = A(x, y)$。
    我们在上一步已经确定了 $\delta(y, y)=1$，所以式子最后那一项 $A(x, y)\delta(y, y)$ 已经等于等号右边的 $A(x, y)$ 了。
    这意味着，前面所有的项加起来必须等于 0：
    $$A(x, x)\delta(x, y) + A(x, x')\delta(x', y) + \dots = 0$$
    为了让它对任意 $A$ 都恒成立（无论 $A$ 取什么值），必须要求所有系数 **$\delta(z, y) = 0$**（其中 $z < y$）。

**结论 1**：要在这种卷积下保持不变，必须使用函数：
$$\delta(x, y) = [x = y] = \begin{cases} 1 & x = y \\ 0 & x \ne y \end{cases}$$

**形式化已知条件**

已知条件是 $g(y) = \sum_{x \le y} f(x)$。
引入常函数 $\zeta(x, y) = 1$ （当 $x \le y$ 时）。
原式可以写成卷积形式（视 $f, g$ 为向量，$A, B$ 为矩阵）：
$$g(y) = \sum_{x \le y} f(x) \zeta(x, y)$$
在代数层面上，这等价于：
$$g = f * \zeta$$

**推导 $\mu$**

我们的目标是求 $f$。
既然 $g = f * \zeta$，我们在两边同乘一个 $\zeta$ 的逆元（记作 $\mu$）：
$$g * \mu = (f * \zeta) * \mu$$
利用结合律：
$$g * \mu = f * (\zeta * \mu)$$
为了消掉 $\zeta$，我们要求 $\mu$ 满足：
$$\zeta * \mu = \delta$$
这样就有：
$$g * \mu = f * \delta = f$$
即 **$f(y) = \sum_{x \le y} g(x)\mu(x, y)$**。

现在的问题核心变成了：**如何找到这个 $\mu$，使得 $\zeta * \mu = \delta$？**

根据 $\zeta * \mu = \delta$ 的定义，展开卷积公式：
$$\sum_{x \le z \le y} \zeta(x, z) \mu(z, y) = \delta(x, y)$$

因为对于 $x \le z$，$\zeta(x, z)$ 恒等于 1，所以式子简化为：
$$\sum_{x \le z \le y} \mu(z, y) = \delta(x, y)$$

这也是 $\mu$ 定义里是 $\mu(x, z)$ 还是 $\mu(z, y)$ 的区别。由于左逆元等于右逆元（因为我们定义的卷积的形式），我们通常习惯计算 $\mu * \zeta = \delta$，即：
$$\sum_{x \le z \le y} \mu(x, z) \zeta(z, y) = \delta(x, y)$$
简化后（因为 $\zeta(z, y)=1$）：
$$\sum_{x \le z \le y} \mu(x, z) = \delta(x, y)$$

我们对区间 $[x, y]$ 的大小进行分类讨论：

1.  **当 $x = y$ 时（区间长度为1）：**
    $$\mu(x, x) = \delta(x, x)$$
    **$\mu(x, x) = 1$**

2.  **当 $x < y$ 时（区间长度大于1）：**
    $$\sum_{x \le z \le y} \mu(x, z) = \delta(x, y)$$
    因为 $x \ne y$，所以 $\delta(x, y) = 0$。
    $$\sum_{x \le z \le y} \mu(x, z) = 0$$
    我们将末项（$z=y$ 的项）分离出来：
    $$\left( \sum_{x \le z < y} \mu(x, z) \right) + \mu(x, y) = 0$$
    移项得到 $\mu(x, y)$ 的递推式：
    **$$\mu(x, y) = - \sum_{x \le z < y} \mu(x, z)$$**
$Q.E.D$


#### 1.2 从矩阵视角看待这个反演

所有的反演公式，都可以抽象为两个数列（或函数） $f$ 和 $g$ 之间的线性关系：
$$g(y) = \sum_{x \preceq y} \zeta(x, y) f(x)$$
这写成矩阵形式就是：
$$\mathbf{g} = \mathbf{Z} \times \mathbf{f}$$其中 $\mathbf{Z}$ 是一个变换矩阵。
所谓的“反演”，就是求逆矩阵 $\mathbf{M} = \mathbf{Z}^{-1}$：$$\mathbf{f} = \mathbf{Z}^{-1} \times \mathbf{g} = \mathbf{M} \times \mathbf{g}$$
对应的形式就是
$$f(x) = \sum_{y \preceq x} \mu(y, x) g(y)$$

#### 1.3. 通用反演定理

于是我们得到了这个很好看的式子

若有两个定义在偏序集 $P$ 上的函数 $f, g$ 满足“和”的关系：

$$g(x) = \sum_{y \le x} \zeta(y, x) f(y)$$

则可以通过 $\mu$ 函数反解出 $f$：

$$f(x) = \sum_{y \le x} \mu(y, x) g(y)$$

#### 1.4. 这暗示我们啥东西？
 
我们通过定义一个矩阵乘法状物的卷积，把所有在偏序集上的反演公式都统一了起来。

其中 $\zeta * \mu = \delta$ 是一个核心方程，$\mu$ 是 $\zeta$ 的逆元。

### 容斥原理与子集/超集反演

#### 2.1 容斥原理及其补集形式

有一个集合的集合 $A=\{S_i\}$ ，那么：

$$\left\lvert \bigcup_{i=1}^n S_i \right\rvert = \sum_{i=1}^n (-1)^{i-1} \sum_{\{a_k\}, a_k < a_{k+1}} \left\lvert \bigcap_{j=1}^i S_{a_j} \right\rvert$$

>这是显然的，要证也可以通过二项式定理证明

容斥原理的补集形式

$$\left\lvert \bigcap_{i=1}^n S_i \right\rvert = \lvert U \rvert - \left\lvert \bigcup_{i=1}^n \overline{S_i} \right\rvert$$

>其实画个venn图就能看出来

#### 2.2 子集/超集反演

$$f(S) = \sum_{T \subseteq S} g(T) \iff g(S) = \sum_{T \subseteq S} (-1)^{|S|-|T|} f(T)$$

$$f(S) = \sum_{S \subseteq T} g(T) \iff g(S) = \sum_{S \subseteq T} (-1)^{\lvert T \rvert - \lvert S \rvert} f(T)$$

证明：
**引理**  $\mu$ 具有积性，具体来说，若偏序集 $P = P_1 \times P_2$，则 $\mu_P((x_1, x_2), (y_1, y_2)) = \mu_{P_1}(x_1, y_1) \cdot \mu_{P_2}(x_2, y_2)$。

证：$\mu$ 函数的唯一定义特征是：
对于任意区间 $[Start, End]$，所有子元素的 $\mu$ 值之和必须等于1 （当 $Start = End$ 时）
值之和必须等于 0 （当 $Start < End$ 时）
只要能证明 $\mu_P(x) \cdot \mu_Q(y)$ 满足这个特征，那它就是 $\mu_{P \times Q}$。

设 $S = (x_1, y_1)$ 是起点，$E = (x_2, y_2)$ 是终点。我们需要计算区间 $[S, E]$ 里所有元素的“分量 $\mu$ 乘积”之和：$$\text{Sum} = \sum_{S \le (u, v) \le E} \mu_P(x_1, u) \cdot \mu_Q(y_1, v)$$

因为积偏序集中，$u$ 和 $v$ 的选取是独立的（$x_1 \le u \le x_2$ 且 $y_1 \le v \le y_2$），我们可以把双重求和拆成两个括号相乘：$$\text{Sum} = \left( \sum_{x_1 \le u \le x_2} \mu_P(x_1, u) \right) \times \left( \sum_{y_1 \le v \le y_2} \mu_Q(y_1, v) \right)$$

根据 $\mu$ 的定义，括号里的求和结果只能是 $1$ 或 $0$：
左括号 $= \delta(x_1, x_2)$ （只有 $x_1=x_2$ 时是 1，否则是 0）
右括号 $= \delta(y_1, y_2)$ （只有 $y_1=y_2$ 时是 1，否则是 0）

情况 A：起点 = 终点即 $x_1=x_2$ 且 $y_1=y_2$。此时 $\text{Sum} = 1 \times 1 = 1$。 $\implies$ 满足定义！
情况 B：起点 < 终点这意味着 $x$ 和 $y$ 中至少有一个不等（例如 $x_1 < x_2$）。那么对应的那个括号求和就是 $0$。$$\text{Sum} = 0 \times (\dots) = 0 \quad \text{或} \quad (\dots) \times 0 = 0$$$\implies$ 满足定义！

$Q.E.D$


布尔格（所有子集构成的格）同构于 $k$ 个 链（Chain） $L_2 = \{0, 1\}$ 的直积。
即：$\mathcal{P}(\{1, \dots, k\}) \cong L_2 \times L_2 \times \dots \times L_2$。（每个元素选或不选对应 0 或 1）。
Möbius 函数具有积性：若偏序集 $P = P_1 \times P_2$，则 $\mu_P((x_1, x_2), (y_1, y_2)) = \mu_{P_1}(x_1, y_1) \cdot \mu_{P_2}(x_2, y_2)$。
对于单个链 
$0 \le 1$：$\mu(0, 0) = 1$
$\mu(0, 1) = -1$ （因为 $\mu(0,0) + \mu(0,1) = 0$）
对于集合 $A \subseteq B$，设 $|B| - |A| = k$。这相当于在 $k$ 个维度上从 $0$ 变到了 $1$，而在其他维度上保持不变。因此：$$\mu(A, B) = \underbrace{(-1) \times (-1) \times \dots \times (-1)}_{k \text{ 次}} = (-1)^k$$

>超集反演同理，证明留作作业

### 二项式反演 (Binomial Inversion)

二项式反演是集合包含偏序集（即布尔格）上的反演在计数问题中的投影。它处理的是“恰好满足 $k$ 个性质”与“至少满足 $k$ 个性质”之间的转换。

#### 3.1 形式一（对称形式）

这是最对称的一种形式，常用于证明其他等式。

$$f(n) = \sum_{i=0}^n (-1)^i \binom{n}{i} g(i) \iff g(n) = \sum_{i=0}^n (-1)^i \binom{n}{i} f(i)$$



#### 3.2 形式二（常用形式/多退少补）

通常 $g(i)$ 表示“钦定选 $i$ 个满足性质，其余随意的方案数”，$f(i)$ 表示“恰好 $i$ 个满足性质的方案数”。

$$f(n) = \sum_{i=0}^n \binom{n}{i} g(i) \iff g(n) = \sum_{i=0}^n (-1)^{n-i} \binom{n}{i} f(i)$$

我们证明一下形式二：

直接套用子集反演公式：
$$f(n) = \sum_{i=0}^n \binom{n}{i} g(i) \iff f(S) = \sum_{T \subseteq S} g(T)$$
$$g(S) = \sum_{S \subseteq T} (-1)^{\lvert T \rvert - \lvert S \rvert} f(T)$$
我们只关心大小，所以把大小为k的集合合并
$$g(n) = \sum_{i=0}^n (-1)^{n-k} \binom{n}{k} f(i)$$


### 莫比乌斯反演

$$f(n) = \sum_{d|n} g(d) \iff g(n) = \sum_{d|n} \mu(d) f\left(\frac{n}{d}\right)$$

证明：

我们取偏序集为 **正整数整除格** $D = (\mathbb{Z}^+, \mid)$。
关系定义为：$a \le b \iff a \mid b$。

此时，我们需要证明：**关联代数 $I(D)$ 可以退化为狄利克雷代数。**

#### 核心引理：区间的结构同构 

**命题**：对于任意 $d \mid n$，偏序区间 $[d, n]$ 与区间 $[1, n/d]$ 是**序同构**的。

>**序同构**：两个偏序集 $A$ 和 $B$ 是序同构的，当且仅当存在双射 $\phi: A \to B$，使得 $\phi$ 和 $\phi^{-1}$ 都保持偏序关系。

>其实就是两个偏序集的dag相同

**证明**：
1.  定义映射 $\phi: [d, n] \to [1, n/d]$，法则为 $\phi(z) = z/d$。
2.  **双射性**：
    * 若 $z \in [d, n]$，则 $d \mid z \mid n$，故 $1 \mid (z/d) \mid (n/d)$，即 $\phi(z) \in [1, n/d]$。显然这是可逆的。
3.  **保序性**：
    * 对于任意 $a, b \in [d, n]$，我们需要证明 $a \mid b \iff \phi(a) \mid \phi(b)$。
    * 根据整除定义：$a \mid b \iff \exists k \in \mathbb{Z}, b = ak$。
    * 等式两边同除以 $d$：$b/d = (a/d)k \iff \phi(b) = \phi(a)k$。
    * 这等价于 $\phi(a) \mid \phi(b)$。

**结论**：区间 $[d, n]$ 的偏序结构完全等同于 $[1, n/d]$。


由于 $\mu(x, y)$ 的值仅由区间 $[x, y]$ 的**拓扑结构**决定（由 $\mu$ 的递归定义可证，同构的偏序集具有相同的 $\mu$ 值）。

由核心引理可知，区间 $[d, n]$ 的结构仅依赖于商 $n/d$。
因此，我们可以定义**约化函数**。

对于关联代数中的任意函数 $h(x, y)$，若其满足 $h(x, y) = h(kx, ky)$（即具有平移不变性），我们可以定义对应的一元算术函数 $\tilde{h}$：
$$\tilde{h}(k) \equiv h(1, k)$$
从而有：
$$h(d, n) = \tilde{h}\left(\frac{n}{d}\right)$$

**检查 $\zeta$ 和 $\mu$ 是否符合此条件：**
1.  **Zeta**: $\zeta(d, n) = 1 \iff d \mid n$。
    $\zeta(1, n/d) = 1 \iff 1 \mid (n/d)$。
    显然恒成立，故 $\zeta(d, n) = \tilde{\zeta}(n/d) = 1$。
    这里 $\tilde{\zeta}$ 就是数论中的常数函数 $\mathbf{1}(n) = 1$。

2.  **Mu**: 由于 $\mu$ 是 $\zeta$ 的逆元，且 $\zeta$ 具有平移不变性，由代数性质可知 $\mu$ 也必然继承此性质（同构区间的逆元结构也相同）。
    定义数论莫比乌斯函数 $\mu_{NT}(k) = \mu(1, k)$。
    则 $\mu(d, n) = \mu_{NT}(n/d)$。

现在我们将广义反演公式代入整除格环境。

**广义形式**：
$$f(n) = \sum_{d \mid n} g(d) \mu(d, n)$$
*(注：这里  $d \le n$ 即 $d \mid n$)*

**代入降维后的 $\mu$**：
$$f(n) = \sum_{d \mid n} g(d) \mu_{NT}\left(\frac{n}{d}\right)$$

为了验证这个 $\mu_{NT}$ 确实是我们熟知的那个函数，我们检查它的一元卷积性质。
在广义代数中：$\mu * \zeta = \delta$。
对应的一元卷积（狄利克雷卷积）为：
$$(\tilde{\mu} * \tilde{\zeta})(n) = \sum_{d \mid n} \tilde{\mu}(d) \tilde{\zeta}\left(\frac{n}{d}\right) = \sum_{d \mid n} \mu_{NT}(d) \cdot 1$$

而在广义代数中，$\delta(x, y)$ 降维后对应单位函数 $\epsilon(n) = [n=1]$。
>为啥？此时$d=n$,$n/d=1$

因此：
$$\sum_{d \mid n} \mu_{NT}(d) = [n=1]$$

这正是数论中莫比乌斯函数的**定义式**。

#### 最终结论

通过**整除格区间 $[d, n] \cong [1, n/d]$ 的序同构**，我们将定义在 $I(D)$ 上的广义莫比乌斯反演：
$$f(n) = \sum_{d \mid n} g(d)\mu(d, n)$$

严格推导为数论形式：
$$f(n) = \sum_{d \mid n} g(d)\mu_{NT}\left(\frac{n}{d}\right)$$

证毕。

以下是常用式子

$$
\sum_{d|n} \varphi(d) = n
$$

$$
\sum_{d|n} \mu(d) = [n = 1] = 
\begin{cases} 
1 & n=1 \\
0 & n>1 
\end{cases}
$$

把$n$换成$gcd(a,b)$


$$
\sum_{d|gcd(a,b)} \mu(d) = [gcd(a,b) = 1]
\begin{cases} 
1 & gcd(a,b)=1 \\
0 & gcd(a,b)>1 
\end{cases}
$$

初等证明前已述及


### Min-Max 容斥

Min-Max 容斥用于将“全集中最大值（最后出现）的问题”转化为“子集中最小值（最先出现）的问题”。在概率期望中，$\min$ 通常比 $\max$ 好算得多。

#### 公式

对于全序集合 $S$ 和其上的值 $\{x_i\}$：


$$\max_{i \in S}{}_k x_i = \sum_{T \subseteq S, T \ne \emptyset} (-1)^{|T|-k} \binom{|T|-1}{k-1} \min_{j \in T} x_j$$

$$\min_{i \in S}{}_k x_i = \sum_{T \subseteq S,T \ne \emptyset} (-1)^{|T|-k} \binom{|T|-1}{k-1} \max_{j \in T} x_j$$

其实 **min_max 容斥** 在期望意义下也满足：

$$E(\max_{i \in S}{}_k x_i) = \sum_{T \subseteq S} (-1)^{|T|-k} \binom{|T|-1}{k-1} E(\min_{j \in T} x_j)$$

$$E(\min_{i \in S}{}_k x_i) = \sum_{T \subseteq S} (-1)^{|T|-k} \binom{|T|-1}{k-1} E(\max_{j \in T} x_j)$$

由期望线性性可知。

>期望的线性性告诉我们：和的期望等于期望的和。
即 $E[\sum c_i \cdot V_i] = \sum c_i \cdot E[V_i]$，无论这些随机变量 $V_i$ 之间是否独立。
$$\begin{aligned}
E[Y] &= E\left[ \sum_{T \subseteq S} a(|T|) \cdot Z_T \right] \\
&= \sum_{T \subseteq S} a(|T|) \cdot E[Z_T]  \quad (\text{常数提出，求和拆开})
\end{aligned}$$

特殊情况 ($k=1$, 最大值):

$$\max(S) = \sum_{T \subseteq S, T \ne \emptyset} (-1)^{|T|-1} \min(T)$$

#### 初等证明

我们需要构造一个关于集合大小的系数函数 $a(|T|)$，使得等式成立：

$$\text{第 } k \text{ 大值} = \sum_{T \subseteq S} a(|T|) \min(T)$$

1.分析元素的贡献
考虑 $S$ 中第 $r$ 大的那个元素，记为 $x_{(r)}$。
在右边的求和式 $\sum a(|T|) \min(T)$ 中，$x_{(r)}$ 何时会被计入？
只有当 $x_{(r)}$ 是集合 $T$ 的最小值时，$\min(T)$ 才会取到 $x_{(r)}$。

如果 $x_{(r)}$ 是 $T$ 的最小值，那么 $T$ 中的其他元素必须都比 $x_{(r)}$ 大。
在 $S$ 中，比 $x_{(r)}$ 大的元素一共有 $r-1$ 个。
假设我们构造的集合 $T$ 大小为 $m$。除去 $x_{(r)}$ 本身，我们需要从那 $r-1$ 个比它大的数中选出 $m-1$ 个。
方案数为 $\binom{r-1}{m-1}$。

所以，第 $r$ 大的数 $x_{(r)}$ 在右边的总贡献系数是：

$$C(r) = \sum_{m} \binom{r-1}{m-1} a(m)$$

(这里枚举的是集合大小 $m$)

2.建立目标方程
我们希望左边计算出来的结果恰好是第 $k$ 大的值。
这意味着：

当 $r=k$ 时（即它是第 $k$ 大），总系数 $C(r) = 1$。

当 $r \ne k$ 时，总系数 $C(r) = 0$。

令 $N = r-1$ (表示比当前数大的数的个数)，目标方程为：

$$\sum_{m} \binom{N}{m-1} a(m) = [N = k-1]$$

令 $j = m-1$，则 $a(m) = a(j+1)$。方程化为：

$$\sum_{j=0}^N \binom{N}{j} a(j+1) = [N = k-1]$$

3.使用二项式反演求解系数
观察上式，形如 $F(N) = \sum \binom{N}{j} G(j)$。
其中 $F(N) = [N = k-1]$ 是已知结果，$G(j) = a(j+1)$ 是待求系数。
根据二项式反演形式二：

$$G(N) = \sum_{j=0}^N (-1)^{N-j} \binom{N}{j} F(j)$$

代入 $F(j) = [j = k-1]$：

$$\begin{aligned}
a(N+1) &= \sum_{j=0}^N (-1)^{N-j} \binom{N}{j} [j = k-1] \\
\end{aligned}$$

由于求和式中只有 $j=k-1$ 这一项非零（前提是 $N \ge k-1$），直接提取该项：

$$a(N+1) = (-1)^{N-(k-1)} \binom{N}{k-1}$$

4.还原变量
代入上式：

$$\begin{aligned}
a(|T|) &= (-1)^{(|T|-1) - (k-1)} \binom{|T|-1}{k-1} \\
&= (-1)^{|T|-k} \binom{|T|-1}{k-1}
\end{aligned}$$

>max和min在全序上是对称的,所以第二个式子就不证了

>从广义莫反证明min-max容斥是有点难度的，留作读者证明


### 斯特林反演

斯特林反演揭示了普通幂与下降幂/上升幂之间的基底变换关系。


第二类斯特林数 (子集数) $\begin{Bmatrix} n \\ k \end{Bmatrix}$：将 $n$ 个不同元素放入 $k$ 个无区别盒子（非空）的方案数。

第一类斯特林数 (轮换数) $\begin{bmatrix} n \\ k \end{bmatrix}$：将 $n$ 个不同元素排成 $k$ 个轮换（非空）的方案数。

斯特林反演

$$f(n) = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} g(i) \iff g(n) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} f(i)$$

#### 前置知识

**上升幂和下降幂**

上升幂 $x^{\overline{n}} = \prod_{i=0}^{n-1} (x+i)$
下降幂 $x^{\underline{n}} = \frac{x!}{(x-n)!} = \prod_{i=0}^{n-1} (x-i)$

上升幂转普通幂

$$x^{\overline{n}} = \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i\tag{A1}$$

证明：
考虑归纳证明：
$n=0$ 时，等式两边皆为 $1$，等式成立
$n=1$ 时，等式左边等于 $x$ ，等式右边等于 $x$ ，等式成立。

$$\begin{aligned}
x^{\overline{n+1}} &= (x+n) x^{\overline{n}} \\
&= (x+n) \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i \\
&= x \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i + n \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} x^i \\
&= \sum_{i=1}^{n+1} \begin{bmatrix} n \\ i-1 \end{bmatrix} x^{i} + n \sum_{i=0}^{n+1} \begin{bmatrix} n \\ i \end{bmatrix} x^i \\
&= \sum_{i=0}^{n+1} \left( \begin{bmatrix} n \\ i-1 \end{bmatrix} + n \begin{bmatrix} n \\ i \end{bmatrix} \right) x^i \\
&= \sum_{i=0}^{n+1} \begin{bmatrix} n+1 \\ i \end{bmatrix} x^i
\end{aligned}$$

下降幂转普通幂

$$x^{\underline{n}} = \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \tag{A2}$$

证明：
同样考虑归纳证明：
$n=0$ 时，等式两边皆为 $1$ ，等式成立
$n=1$ 时，等式两边皆为 $x$ ，等式成立

$$\begin{aligned}
x^{\underline{n+1}} &= (x-n) x^{\underline{n}} \\
&= (x-n) \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \\
&= x \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i - n \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \\
&= \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^{i+1} - n \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \\
&= \sum_{i=1}^{n+1} \begin{bmatrix} n \\ i-1 \end{bmatrix} (-1)^{n-i+1} x^{i} - n \sum_{i=0}^{n+1} \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \\
&= \sum_{i=1}^{n+1} \begin{bmatrix} n \\ i-1 \end{bmatrix} (-1)^{n-i+1} x^{i} + n \sum_{i=0}^{n+1} \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i+1} x^i \\
&= \sum_{i=0}^{n+1} \left( \begin{bmatrix} n \\ i-1 \end{bmatrix} + n \begin{bmatrix} n \\ i \end{bmatrix} \right) (-1)^{n-i+1} x^i \\
&= \sum_{i=0}^{n+1} \begin{bmatrix} n+1 \\ i \end{bmatrix} (-1)^{(n+1)-i} x^i
\end{aligned}$$

普通幂转为下降幂

$$x^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} x^{\underline{i}} \quad \tag{A3} $$

证明：考虑组合意义
假设我们有：$n$ 个不同的球（标号 $1, 2, \dots, n$）$x$ 个不同的盒子（标号 $1, 2, \dots, x$）
我们要计算：把这 $n$ 个球任意放入这 $x$ 个盒子中，允许盒子为空，一共有多少种方案？
左边 对于每一个球，我们都可以从 $x$ 个盒子中任选一个放入。所以总方案数为 $x^n$。
右边 假设最后放完球后，恰好有 $i$ 个盒子 里有球（即非空盒子数为 $i$）
1.选出这 $i$ 个盒子我们在 $x$ 个不同的盒子中，选出 $i$ 个将被使用的盒子。方案数为组合数：$\binom{x}{i}$
2.把 $n$ 个球分给这 $i$ 个盒子（暂时不区分盒子的顺序）
这相当于把 $n$ 个不同的元素，划分成 $i$ 个非空的集合（堆）。
这正是第二类斯特林数 $\begin{Bmatrix} n \\ i \end{Bmatrix}$ 的定义！
3.把这 $i$ 堆球放入刚才选好的 $i$ 个盒子里因为盒子是不同的，我们需要决定哪一堆球放进哪一个盒子。这相当于 $i$ 个元素的全排列。方案数为：$i!$
方案总数为：
$$\ \binom{x}{i} \times \begin{Bmatrix} n \\ i \end{Bmatrix} \times i!=\begin{Bmatrix} n \\ i \end{Bmatrix} x^{\underline{i}}$$

普通幂转上升幂

$$x^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^{n-i} x^{\overline{i}} \tag{A4}$$

我们会发现一个关于负数的重要性质：
$$(-x)^{\underline{n}} = (-1)^n x^{\overline{n}}$$
推导引理：
$$\begin{aligned}
(-x)^{\underline{n}} &= (-x)(-x-1)(-x-2)\dots(-x-n+1) \\
&= \left[(-1)(x)\right] \cdot \left[(-1)(x+1)\right] \cdot \left[(-1)(x+2)\right] \dots \left[(-1)(x+n-1)\right] \\
&= (-1)^n \cdot \underbrace{x(x+1)(x+2)\dots(x+n-1)}_{x^{\overline{n}}} \\
&= (-1)^n x^{\overline{n}}
\end{aligned}$$

我们已知普通幂转下降幂的公式：
$$x^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} x^{\underline{i}}$$
在这个恒等式中，将 $x$ 替换为 $-x$：
$$(-x)^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-x)^{\underline{i}}$$
左边展开为 $(-1)^n x^n$，右边利用引理代换：
$$(-1)^n x^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} \left[ (-1)^i x^{\overline{i}} \right]$$
两边同时除以 $(-1)^n$（或者乘以 $(-1)^n$）：
$$\begin{aligned}
x^n &= \frac{1}{(-1)^n} \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^i x^{\overline{i}} \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} \frac{(-1)^i}{(-1)^n} x^{\overline{i}} \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^{i-n} x^{\overline{i}}
\end{aligned}$$
由于 $(-1)^{i-n} = (-1)^{n-i}$（指数差偶数倍不影响符号），整理得：
$$x^n = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^{n-i} x^{\overline{i}}$$



**反转公式**

$$\sum_{i=m}^n (-1)^{n-i} \begin{Bmatrix} n \\ i \end{Bmatrix} \begin{bmatrix} i \\ m \end{bmatrix} = [m=n] \tag{1}$$

$$\sum_{i=m}^n (-1)^{m-i} \begin{bmatrix} n \\ i \end{bmatrix} \begin{Bmatrix} i \\ m \end{Bmatrix} = [m=n] \tag{2}$$

反转公式（1）证明(利用下降幂转普通幂/普通幂转下降幂)：

$$\begin{aligned}
x^{\underline{n}} &= \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} x^i \\
&= \sum_{i=0}^n \begin{bmatrix} n \\ i \end{bmatrix} (-1)^{n-i} \sum_{j=0}^i \begin{Bmatrix} i \\ j \end{Bmatrix} x^{\underline{j}} \\
&= \sum_{i=0}^n x^{\underline{i}} \sum_{j=i}^n (-1)^{n-j} \begin{bmatrix} n \\ j \end{bmatrix} \begin{Bmatrix} j \\ i \end{Bmatrix}
\end{aligned}$$
当 $i=n$ 时，等式右边为 $x^{\underline{n}}$，等式成立
当 $i<n$ 时，等式右边为 要为$0$，等式成立



反转公式（2）证明：

$$\begin{aligned}
x^n &= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} x^{\underline{i}} \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^i (-x)^{\overline{i}} \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} (-1)^i \sum_{j=0}^i \begin{bmatrix} i \\ j \end{bmatrix} (-x)^j \\
&= \sum_{i=0}^n x^i \sum_{j=i}^n (-1)^{i-j} \begin{Bmatrix} n \\ j \end{Bmatrix} \begin{bmatrix} j \\ i \end{bmatrix}
\end{aligned}$$

同理

斯特林反演

$$f(n) = \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} g(i) \iff g(n) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} f(i)$$

上式中一二类斯特林数可以互换位置。

证明：
已知： $g(n) = \sum_{i=0}^n (-1)^{n-i} \begin{bmatrix} n \\ i \end{bmatrix} f(i)$

$$\begin{aligned}
f(n) &= \sum_{i=0} [i=n] f(i) \\
&= \sum_{i=0}^n \sum_{j=i}^n \begin{Bmatrix} n \\ j \end{Bmatrix} \begin{bmatrix} j \\ i \end{bmatrix} (-1)^{j-i} f(i) \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} \sum_{j=0}^i (-1)^{i-j} \begin{bmatrix} i \\ j \end{bmatrix} f(j) \\
&= \sum_{i=0}^n \begin{Bmatrix} n \\ i \end{Bmatrix} g(i)
\end{aligned}$$

#### 另一个视角


**斯特林反演本质上是“集合分划格”（Partition Lattice）上的广义莫比乌斯反演。**

就像：
* **二项式反演** 对应 **子集格（布尔格）** 上的莫比乌斯反演。
* **数论莫比乌斯反演** 对应 **整除格** 上的莫比乌斯反演。
* **斯特林反演** 对应 **集合分划格** 上的莫比乌斯反演。


##### 1. 什么是集合分划格 $\Pi_n$？

我们定义一个偏序集（Poset） $P = \Pi_n$。
* **元素**：集合 $S = \{1, 2, \dots, n\}$ 的所有**分划**。
    * 例如 $n=3$，$\{\{1,2\}, \{3\}\}$ 就是一个分划。
* **偏序关系 $\le$**：
    * 对于两个分划 $\sigma$ 和 $\tau$，如果 $\sigma$ 中的每一个块（block）都完全包含在 $\tau$ 的某一个块中，我们称 $\sigma \le \tau$（$\sigma$ 比 $\tau$ 更“细”，或者 $\tau$ 比 $\sigma$ 更“粗”）。
    * **最小元 $\hat{0}$**：$\{\{1\}, \{2\}, \dots, \{n\}\}$（全部分开，最细）。
    * **最大元 $\hat{1}$**：$\{\{1, 2, \dots, n\}\}$（全部在一起，最粗）。

##### 2. 这个格上的 Zeta 和 Möbius 函数

在 $\Pi_n$ 上定义广义莫比乌斯反演的两个核心函数：

Zeta 函数 $\zeta(\sigma, \tau)$
定义为：若 $\sigma \le \tau$，则为 $1$，否则为 $0$。
它对应着**求和**操作，也就是我们熟悉的“第二类斯特林数”方向。

Möbius 函数 $\mu(\sigma, \tau)$
它是 $\zeta$ 的逆。在集合分划格中，$\mu$ 的取值非常特殊：
对于区间 $[\hat{0}, \hat{1}]$（即从全分散到全聚合），有著名的定理：
$$\mu(\hat{0}, \hat{1}) = (-1)^{n-1} (n-1)!$$

>咋证？
我们要证的目标是 $M_n = (-1)^{n-1}(n-1)!$，其中 $M_n$ 简记为 $n$ 个元素分划格最顶端的 $\mu(\hat{0}, \hat{1})$。
利用 $\sum \mu = 0$ 构造递推
**1. 莫比乌斯函数的定义**
对于任意 $n > 1$，分划格 $\Pi_n$ 中所有元素的 $\mu$ 值之和必须为 0：
$$\sum_{\sigma \in \Pi_n} \mu(\hat{0}, \sigma) = 0$$
换句话说：
$$M_n = - \sum_{\sigma \neq \hat{1}} \mu(\hat{0}, \sigma)$$
*(最顶上的那一项，等于底下所有项之和的相反数)*
**2. 巧妙的分组**
我们根据 **“元素 $n$ 所在的块的大小”** 来对所有的分划 $\sigma$ 进行归类。
设元素 $n$ 所在的块为 $B$，设 $|B| = i$。
$i$ 的取值范围是 $1$ 到 $n$。
选出这个块 $B$ 的方案数是 $\binom{n-1}{i-1}$（因为 $n$ 必须在里面，从剩下 $n-1$ 个里选 $i-1$ 个陪它）。
**3. 结构的乘积**
对于一个固定的块 $B$（大小为 $i$），剩下的 $n-i$ 个元素组成了某种分划 $\tau$。
因为块之间互不干扰，$\mu$ 值具有乘积性质：
$$\mu(\hat{0}, \sigma) = \underbrace{M_i}_{\text{块}B\text{的贡献}} \times \underbrace{\mu(\text{剩余部分的}\tau)}_{\text{剩下的贡献}}$$
**4. 所有的项求和**
把刚才的 $\sum \mu = 0$ 按照 $i$ 展开：
$$0 = \sum_{i=1}^n \binom{n-1}{i-1} M_i \times \underbrace{\left( \sum_{\tau \in \Pi_{n-i}} \mu(\hat{0}, \tau) \right)}_{\text{剩余部分的所有情况之和}}$$
**5. 奇迹发生了**
请盯着最后那个括号里的部分：$\sum_{\tau \in \Pi_{n-i}} \mu(\hat{0}, \tau)$。
这是一个大小为 $n-i$ 的全部分划格的 $\mu$ 之和。
根据莫比乌斯函数的定义，只要 $n-i > 1$，这个和就是 **0**！
这个和不为 0 的只有两种情况：
    **$n-i = 1$**：只剩 1 个元素，和为 $M_1 = 1$。
    **$n-i = 0$**：没有剩余元素（即 $i=n$），定义为 1。
**6. 最后的递推**
因为只有 $n-i=0$ 和 $n-i=1$ 有值，长长的求和式瞬间只剩下两项：
**当 $i=n$ 时**（全在一起）：
    系数是 $\binom{n-1}{n-1} M_n \times 1 = M_n$
**当 $i=n-1$ 时**（剩一个孤立点）：
    系数是 $\binom{n-1}{n-2} M_{n-1} \times M_1 = (n-1) M_{n-1}$
方程变成了：
$$M_n + (n-1)M_{n-1} = 0$$
$$\Rightarrow M_n = -(n-1) M_{n-1}$$
**7. 求解**
 $M_1 = 1$
 $M_2 = -1 \cdot M_1 = -1$
 $M_3 = -2 \cdot M_2 = 2$
 ...
 $M_n = (-1)^{n-1} (n-1)!$


更一般地，对于任意 $\sigma \le \tau$，$\mu(\sigma, \tau)$ 的值只与它们之间的结构差异有关，其数值形式就是**带符号的第一类斯特林数**的乘积形式。


##### 3. 如何连接到斯特林反演？

我们通常看到的斯特林反演公式是关于 $n$ 和 $k$ 的，而不是关于具体分划 $\sigma$ 的。这是因为斯特林反演是集合分划格反演的 **“约化”（Reduced）形式**。


第一步：从组合意义看 $x^n$ (Zeta 变换)

考虑映射 $f: \{1, \dots, n\} \to \{1, \dots, x\}$。总共有 $x^n$ 种映射。
我们可以根据这个映射的 **核（Kernel）** 来分类。核是一个分划 $\sigma$，也就是把映射到同一个值的元素归为一个块。

如果我们设 $N(\sigma)$ 是“恰好以 $\sigma$ 为核”的映射数量（即 $\sigma$ 的每个块映射到不同的值）。
那么总数 $x^n$ 就是对所有可能的核 $\sigma$ 求和（这就是 Zeta 变换的体现）：
$$x^n = \sum_{\sigma \in \Pi_n} N(\sigma)$$

注意到，如果分划 $\sigma$ 有 $k$ 个块（记为 $|\sigma|=k$），那么 $N(\sigma) = x^{\underline{k}}$（从 $x$ 个值选 $k$ 个排列）。
而这也正好对应了有多少个分划具有 $k$ 个块——这正是**第二类斯特林数** $\begin{Bmatrix} n \\ k \end{Bmatrix}$。

所以上面的式子变成了我们熟悉的：
$$x^n = \sum_{k=0}^n \begin{Bmatrix} n \\ k \end{Bmatrix} x^{\underline{k}}$$
**(这对应 $\zeta$ 变换，也就是 $g = \zeta * f$)**

>听不懂？见A3.普通幂转下降幂的组合意义

第二步：反演 (Möbius 变换)

根据广义莫比乌斯反演原理，如果我们想求 $x^{\underline{n}}$（即强行要求核为 $\hat{0}$ 且全部映射到不同值的方案数），我们需要用 $\mu$ 函数倒推回去。

在“约化”的代数视角下，$\Pi_n$ 的 Möbius 函数系数对应正是 **第一类斯特林数**。

具体来说，由于 $\mu(\hat{0}, \hat{1}) = (-1)^{n-1}(n-1)!$，这其实是第一类斯特林数 $s(n, 1)$。
推广到从 $n$ 个元素的块反演回 $k$ 个元素的块，系数正是：
$$s(n, k) = (-1)^{n-k} \begin{bmatrix} n \\ k \end{bmatrix}$$

>咋推广？
对于 $n$ 个元素的**全部分划格** $\Pi_n$，从最底（全散）到最顶（全聚）的莫比乌斯函数是：
$$\mu_{\Pi_n}(\hat{0}, \hat{1}) = (-1)^{n-1}(n-1)!$$
**那如果不是到最顶 $\hat{1}$，而是到一个中间状态 $\sigma$ 呢？**
假设分划 $\sigma$ 将 $n$ 个元素分成了 $k$ 个块，块的大小分别为 $b_1, b_2, \dots, b_k$（显然 $\sum b_i = n$）。
**关键性质：**
区间 $[\hat{0}, \sigma]$ 在结构上等价于 **$k$ 个独立的小分划格的直积**。
$$[\hat{0}, \sigma] \cong \Pi_{b_1} \times \Pi_{b_2} \times \dots \times \Pi_{b_k}$$
因为莫比乌斯函数在直积上具有**积性**（Multiplicative），所以：
$$\mu(\hat{0}, \sigma) = \prod_{i=1}^k \mu_{\Pi_{b_i}}(\hat{0}, \hat{1})$$
代入基础结论：
$$\begin{aligned}
\mu(\hat{0}, \sigma) &= \prod_{i=1}^k \left[ (-1)^{b_i-1} (b_i-1)! \right] \\
&= (-1)^{\sum (b_i - 1)} \prod_{i=1}^k (b_i-1)! \\
&= (-1)^{n-k} \prod_{i=1}^k (b_i-1)!
\end{aligned}$$
这是一个非常重要的中间结论：**任意分划 $\sigma$ 的莫比乌斯函数值，取决于它的块大小的阶乘积。**
我们在做斯特林反演时，不是针对某一个特定的 $\sigma$，而是把**所有块数（Rank）为 $k$ 的分划**归为一类。
所谓的“反演系数” $s(n, k)$，本质上就是把所有“这就只有 $k$ 个块”的分划的 $\mu$ 值加起来：
$$s(n, k) = \sum_{\substack{\sigma \in \Pi_n \\ |\sigma|=k}} \mu(\hat{0}, \sigma)$$
代入刚才推导的公式：
$$s(n, k) = \sum_{\substack{\sigma \in \Pi_n \\ |\sigma|=k}} \left( (-1)^{n-k} \prod_{i=1}^k (b_i-1)! \right)$$
提公因式 $(-1)^{n-k}$：
$$s(n, k) = (-1)^{n-k} \underbrace{\sum_{\substack{\sigma \in \Pi_n \\ |\sigma|=k}} \left( \prod_{i=1}^k (b_i-1)! \right)}_{\text{这是什么？}}$$
**让我们看看这个求和部分的组合意义：**
**外部求和**：枚举所有把 $n$ 个元素分成 $k$ 个块的方案（分划 $\sigma$）。
**内部乘积** $\prod (b_i-1)!$：对于每一个块（大小为 $b_i$），$(b_i-1)!$ 正好是**圆排列**（Circle Permutation）的方案数。
**合起来的意思是：**
先选定一种分块方式，然后把每个块里的元素排成一个圆环（Cycle）。
把所有分块方式对应的圆环方案加起来，这不就是：
**“把 $n$ 个元素排成 $k$ 个圆环（轮换）的总方案数”吗？**
这正是**无符号第一类斯特林数** $\begin{bmatrix} n \\ k \end{bmatrix}$ 的定义！
所以：
$$s(n, k) = (-1)^{n-k} \begin{bmatrix} n \\ k \end{bmatrix}$$
这就是为什么斯特林反演的系数里藏着圆排列的阶乘，也是它“推广”的内在逻辑。

所以反演公式为：
$$x^{\underline{n}} = \sum_{k=0}^n (-1)^{n-k} \begin{bmatrix} n \\ k \end{bmatrix} x^k$$
**(这对应 $f = \mu * g$)**


### 总结


| 反演名称 | 基础偏序集 (Poset) | 偏序关系 $\le$ | $\zeta(x, y)$ <br> (正向覆盖系数) | $\mu(x, y)$ <br> (反演容斥系数) | 卷积单位元 <br> $\delta(x, y)$ |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **通用定义** | **任意局部有限偏序集** $P$ | $x \le y$ | $1$ 若 $x \le y$ <br> $0$ 若不满足 | $\zeta^{-1}$ (递归定义) | $[x=y]$ |
| **子集反演** <br> (SOS DP) | **布尔格** $B_n$ <br> (Power Set) | $S \subseteq T$ | $1$ | $(-1)^{\|T\|-\|S\|}$ | $[S=T]$ |
| **超集反演** <br> (高维后缀和) | **布尔格** $B_n$ <br> (Dual) | $S \supseteq T$ | $1$ | $(-1)^{\|S\|-\|T\|}$ | $[S=T]$ |
| **二项式反演** <br> (PIE) | **布尔格** (投影到大小) | 大小 $k$ 归类 | $\binom{n}{k}$ | $(-1)^{n-k}\binom{n}{k}$ | $[n=k]$ |
| **数论莫比乌斯** | **整除格** $D_n$ | $a \mid b$ | $1$ | $\mu(b/a)$ | $[a=b]$ |
| **斯特林反演** | **分划格** $\Pi_n$ | 加细 (Refinement) | $\begin{Bmatrix} n \\ k \end{Bmatrix}$ | $(-1)^{n-k}\begin{bmatrix} n \\ k \end{bmatrix}$ | $[n=k]$ |



